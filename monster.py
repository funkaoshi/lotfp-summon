import re
import random

import tables
from dice import d


class Monster(object):
    """
    Models the monster generated by the summon spell, and contains some helper
    methods for doing domination rolls once the monster is created.
    """

    def __init__(self, monster_hd, saved):
        self.hd = monster_hd
        self.ac = 12
        self.move = 120
        self.ml = 10
        self.attacks = 1
        self.damage = 1
        self.damage_die = 6
        self.is_abstract_form = False
        self.original_powers_count = 0
        self.form = None
        self.powers = []
        self.appendages = []
        self._get_monster_form(saved)  # updates self.form, self.is_abstract_form
        self._get_appendages()  # updates self.appendages
        self._get_powers(saved)  # updates ac/move/ml/powers
        self.hp = d(6) + sum(d(6) for i in range(self.hd))

    @property
    def domination_margin(self):
        """
        The creatures domination margin is used to determine how greatly
        (or not) the spell caster dominates the monster.
        """
        return 5 + self.hd + self.original_powers_count

    def domination_roll(self):
        """
        The creatures domination roll is a d20 with bonuses for it's
        power count and hit-dice. We use the original power count because
        the actual powers list doesn't contain every single power that was
        selected. (Powers that augment a monster's stats are extracted from
        that.)
        """
        return self.hd + self.original_powers_count + d(20)

    def _get_monster_form(self, saved):
        """
        The summon spell calls for a d12 roll if the save was a success, or a
        d20 roll if it was a failure. You then determine the form by making a d3
        roll for the 1-12 range, a d10 for the 13-19 range, and a d8 roll for
        on a 20. Since the second set of rolls are a linear distribution, we can
        randomly select from the tables.
        """
        form_roll = d(20) if not saved else None
        if saved or 1 <= form_roll <= 12:
            form = random.choice(tables.FORM)
        elif 13 <= form_roll <= 19:
            form = random.choice(tables.DEADLY_FORM)
        else:
            self.is_abstract_form = True
            form = random.choice(tables.ABSTRACT_FORM)

        self.form = form["name"]

        # some forms include additional powers
        for p in form["powers"]:
            self.powers.append(p)

    def _get_appendages(self):
        """
        You determine appendages by rolling against a table that describes
        appendages, and an adjective that describes them. You decide if you
        have an appendage by rolling a die repeatedly, trying to roll lower than
        your previously roll. There is a linear distribution of choices, so we
        pick randomly from the table.
        """
        die_type = self._get_die_type()
        previous = d(die_type)
        while True:
            roll = d(die_type)
            if roll < previous:
                break
            previous = roll
            adjective = random.choice(tables.APENDAGE_ADJECTIVE)
            noun = random.choice(tables.APENDAGE_NOUN)
            self.appendages.append("%s %s" % (adjective, noun))

    def _get_powers(self, saved):
        """
        Similar to _get_appendages, we select powers from the power table based
        on whether we roll lower than our previous die roll. Once we are done
        picking powers, we process the list we have generated. Any powers that
        simply augment the monsters stats are removed from the list, and we
        adjust the monsters stats accordingly.
        """
        die_type = self._get_die_type()
        previous = d(die_type)
        while True:
            roll = d(die_type)
            if not saved:
                previous = previous + 1
            if roll < previous or roll == 1:
                break
            previous = roll
            self.original_powers_count = self.original_powers_count + 1
            self.powers.append(random.choice(tables.POWERS))

        # Process this list of powers. We will remove powers that modify
        # stats, and simply update the monsters stats. (This is why we
        # store the original power count, as that is used in domination
        # checks.)
        powers = set(self.powers)  # copy & convert to set to remove duplicates
        self.powers = []
        for power in powers:
            power = self._parse_power(power)
            if power:
                self.powers.append(power)

        self.powers = list(set(self.powers))

    def _parse_power(self, power):
        """
        This method looks for powers that augment a monsters statistics, and
        parses the power to adjust the stat in question.
        """
        move = re.match(r"Move (\d+)'", power)
        if move:
            self.move = move.group(1)
            return ""
        ac = re.match(r"AC \+(\d)d(\d+)(, Immune to Normal Weapons)?", power)
        if ac:
            self.ac = self.ac + int(ac.group(1)) * d(int(ac.group(2)))
            if ac.group(3):
                return "Immune to Normal Weapons"
            return None
        ac = re.match(r"\+(\d+) AC", power)
        if ac:
            self.ac = self.ac + int(ac.group(1))
            return None
        if power == "Multiple Attacks (Additional d3 Attacks)":
            self.attacks = self.attacks + d(3)
            return None
        if power == "2 Attacks" and self.attacks < 2:
            self.attacks = 2
            return None
        # power doesn't modify monster stats
        return power

    def _get_die_type(self):
        """
        We pick a die type based on the hit dice of the monster, as outlined
        in the table on page 144 of the Grindhouse rules.
        """
        if 0 == self.hd:
            return 2
        elif 1 == self.hd:
            return 4
        elif 2 <= self.hd <= 4:
            return 6
        elif 5 <= self.hd <= 7:
            return 8
        elif 8 <= self.hd <= 10:
            return 10
        else:
            return 12
